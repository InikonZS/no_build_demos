<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="style.css">  
  </head>
  <body>Canvas demo:
    <div class="sci_wrapper" id="app-main">
    </div>
    <a href="easy1.html">next</a>
    <div style="height: 300px"></div>
    <h2> Так выглядит буфер вершин и индексов без использования webGL</h2>
    <p> В данном случае задается куб из 8 вершин, Буфер индексов сформирован для отдельных линий из пар индексов
      так же webGL использует примитивы такие как VertexList LineList LineStrip, TriangleList, TriangleStrip, TriangleFan
    </p>
    <img src="c1.png" style="width: 30%">
    <div style="height: 300px"></div>
    <h2> Задаем функции для прямого расчета трансформаций</h2>
    <p> так же задаем функцию для применения матричной трансформации. Подробнее она описана в соответствующем
      модуле. Обратим внимание на функцию поворота, как в ней расставлены коэффициенты cos sin -sin cos и
      сравним ее с матрицами поворотов.
    </p>
    <img src="c2.png" style="width: 70%">
    <div style="height: 300px"></div>
    <h2>Здесь реализуем рендеринг созданного буфера с учетом индексации</h2>
    <p>Все должно быть просто, применение индексов означает выполнение цикла для именно индексов, по которым выбирается
      очередная вершина. Так же обратим внимание на то, что функция правильно работает только для LineList формата
      Другие форматы потребуеют читать буфер иначе.
    </p>
    <img src="c3.png" style="width: 70%">

    <div style="height: 300px"></div>
    <h2> Так мы применяем трансформации, процесс похож на вершинный шейдер webGL</h2>
    <p>Скорее даже не на сам шейдер, а на процесс создания матрицы, которая могла бы быть подана в шейдер
      в данном случае трансформации применяются к буфера сразу же. В этом основной недостаток - 
      каждая трансформация должна быть выполнена для всего буфера. Матрицу же можно заранеее сформировать и 
      один раз применить путем умножения для всех вершин буфера.
    </p>
    <img src="ce1.png" style="width: 70%">

    <div style="height: 300px"></div>
    <h2>Так выглядит модель из obj файла</h2>
    <p>Проведем аналогию с ручным созданием массива вершин</p>
    <img src="obj1.png" style="width: 30%">
    <div style="height: 300px"></div>
    <h2>Так же модель содержит другие данные вершин, в данном случае текстурные UV координаты</h2>
    <p>Могут быть еще нормали, в данной модели они так же присутствуют, или другие пары UV координат для мультитекстуринга, цвет вершин и другие параметры</p>
    <img src="obj2.png" style="width: 30%">
    <div style="height: 300px"></div>
    <h2>А здесь все вершины обьединяются в примитивы индексами.</h2>
    <p>Это триангулированная модель, но бывают и полигональные варианты в obj формате.
      Как видно в obj формате записаны через слэш несколько индексов. Эти индексы соотсвествуют
      элементам листов V VT и VN соотвественно. При формировании буфера ГЛ потребуется
      сгруппировать эти параметры в 1 буфер, и его переиндексировать.
      Для упрощения в моей игрушке индексация вовсе не используется, буфер заполняется копированием
      вершин в буфер согласно заданным индексам.
    </p>
    <img src="obj3.png" style="width: 30%">

    <script src="m4.js"></script>
    <script src="vector3d.dev.js"></script>
    <script src="calc.utils.js"></script>
    <script src="obj-loader.utils.js"></script>
    <script src="tf.model.js"></script>
    <script src="control.component.js"></script>
    <script src="easy.js"></script>
  </body>
</html>