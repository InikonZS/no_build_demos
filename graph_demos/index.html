<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="style.css">  
  </head>
  
  <body>
      <h2>Демка</h2>
      <p>На демке загружена уже трехмерная модель с множеством вершин, так же используются нормали для расчета освещения
        Давайте поуправляем ей. Ее можно приблизить или отдалить.
        Можно добавить больше моделей
        Посмотрим, что произойдет если закрасить треугольники. Как видно выглядит это дело не очень, при рендеринге
        важно учитывать последовательность рисования примитивов от дальних к ближним. Так же широко используется z-буфер.
        При добавлении множества моделей получаем уже тормоза, canvas работает медленно
      </p>
    <h2>Canvas demo:</h2>
    <div class="sci_wrapper" id="app-main">
    </div>
    <a href="easy.html">easy_demo</a>
    <a href="clock.html">clock demo</a>
    <a href="prime.html">gl demo</a>
    <a href="index.html">no gl demo</a>
    <div style="height:300px"></div>
    <p>
      О вебГЛ. вебГЛ не является фреймоворком, это фундаментальная технология. Не используя webGL невозможно
      получить аналогичные результаты посредством js. В первую очередь быстродействие.
      GLSL является строго типизированным языком, и содержит множество непривычных типов
      таких как vec2 vec3 vec4 mat2 mat3 mat4 что является векторами и матрицами соответственно и позволяет
      выполнять арифметику с ними. Так же содержится ряд встроенных функций например dot- скалярное произведение,
      reflect - отрачение вектора относитель другого и много другого.
      полностью о языке - https://metanit.com/web/webgl/3.3.php
      полностью о вебГЛ - https://webglfundamentals.org/
    </p>

    <h2> Введение</h2>
    <div>
      <p>о программировании игры на javascript и применении для этой цели canvas
        и webgl технологий.
        У многих вероятно webgl ассоциируется с трехмерной графикой, однако не обязательно средствами webgl
        реализуется именно 3d графика и не обязательно 3d графика выводится средствами webgl
        На самом деле webgl не упрощает работу с графикой, в ней в любом случае присутствует много математических
        расчетов. WebGL лишь позволяет использовать возможности графического ускорителя видеокарты и тем самым
        оптимизируется процесс рендеринга.
       </p> 
       <p>
        Собственно что есть графика:
        в первую очередь графика делится на растровую и векторную. В растровой графике основными примитивами
        являются пиксели, которые размещаются в двумерном массиве, который прямо отображается на экране.
      </p>
      <p>
        векторная графика строится из примитивов, таких как вершины, треугольники, которые обьединяются в модели.
       </p> 
       <img style="width: 80%" src="im5.png">
       <p>
        Процесс перевода векторной графики в растровую называется рендерингом. Механизм рендерига слабо отличается
        для двухмерной и трехмерной графики. Рендеринг можно разделить на 2 этапа
        </p>
        <p>- преобразование вершин в экранные координаты
        </p>
        <p>- установка цвета отдельных пикселей
        </p>
        <p>
        В понятиях webgl эти два этапа выполняются при помощи вершинного и пиксельного шейдера. Шейдеры пишутся на
        специальном языке glsl и выполняются на видеокарте.
        Однако преобразование это может быть выполнено и на js, оно совсем не сложное и в точности совпадает
        с тем, что мы бы сделали шейдером
      </p>
      <h2>Так выглядит цепочка преобразований рендеринга</h2>
    <img style="width: 80%" src="block1.png">
        <p>На рисунке изображена цепочка преобразований, состоящая из</p>
        <ul>

       <li>- матрицы проекции</li>
        <li>- матрицы камеры</li>
        <li>- матрицы мира </li>
      </ul>
      <p>
        Последовательное произведение исходного вектора на все эти матрицы вернет вектор в экранных координатах.
        Стоит заметить, что преобразование для трехмерного пространства будет выполняться с 4х мерным вектором
        и соответственно с матрице 4 на 4. С случае же 2д, размерность их будет 3.
        </p>
        <img style="width: 80%" src="im4.png">
        <p>
        Рассмотрим детальнее для чего все это нужно и как это работает. На самом деле в трехмерной графике нет 
        ничего магического. Она предельно проста
        </p>
        <p>
        Трехмерные модели состоят из набора вершин, связанных индексами в примитивы, например треугольники
        Из набора треугольников строится собственно модель
        </p>
        <p>
        Модель в файле размещается в своей система координат, обычно она центрована в нулевой точке.
        для помещения ее в игровое пространство к ней применяются какие либо трансформации
        например масштабирование, перемещение или повороты. Трансформация любая удобно записывается в виде матрицы.
        Применение трансформации есть умножение всех векторов вершин модели на матрицу. Так же трансфорации могут
        комбинироваться произведением самих матриц. Это очень удобно, потому что позволяет создать сразу необходимые
        функции лишь для базовых трансформации и ими сформировать необходимую матрицу.
        </p>
        <img style="width: 80%" src="im3.png">
        <p>
        Матрица камеры работает аналогично, она выделяется лишь для того, чтобы получить возможность управлять
        не одним обьектом, а всеми обьектами на сцене.
        </p>
        <p>
        Матрица проекции устроена чуть сложнее, и преобразование в экранные координаты имеет свои особенности.
        Простейшим случаем преобразования в экранные координаты может являться просто отбрасываение Z-координаты
        в таком случае мы получаем изометрическую проекцию. Если же требуется получить перспективу, применяется просто
        деление x y координат на преобразованную z составляющую. Так же результат x y z будет совпадать как для обьектов
        расположенных сзади и спереди, поэтому необходимо использовать w составляющую, которая будет отрицательной для
        всех обьектов за камерой.
        </p>
        <img style="width: 80%" src="im6.png">
        <p>
        Существуют готовые алгоритмы формирования матрицы проекции, с учетом угла обзора, размеров экрана вывода, расстояний
        до дальней и ближней плоскости отсечения. Таким образом отображение будет происходить только тех предметов,
        которые попадают в трехмерную трапецию.
        </p>
        <img style="width: 80%" src="im7.png">
        <p>
        Двухмерный случай можно рассматривать как частный случай трехмерного преобразования, в котором исключается
        z координата, так же матрица проекции будет отвечать лишь за масштабирование
        изображения в размеры видимого экрана.
        </p>
    </div>
    <div style="height: 300px"></div>
    
    
    <img style="width: 50%" src="block2.png">
    <div style="height: 300px"></div>
    <img style="width: 50%" src="block3.png">
    <div style="height: 300px"></div>
    <img style="width: 50%" src="block4.png">

    <div style="height: 300px"></div>
    <h2>Так происходят трансформации</h2>
    <p>Здесь мы формируем матрицу просмотра и матрицу проекции, сравнимо с вершинным шейдером</p>
    <img style="width: 80%" src="code1.png">
    <div style="height: 300px"></div>
    <h2>Так происходит вывод на экран преобразованного буфера</h2>
    <p>сравнимо с пиксельным шейдером</p>
    <img style="width: 80%" src="code2.png">
    <div style="height: 300px"></div>
    <h2>Так реализуется анимация</h2>
    <p>Такой подход применяется в случае с webGL так и без него, классика. Так же стоит обратить внимания
      на синхронизацию по времени, requestAnimationFrame имеет для того параметр timeStamp где хранится время
      текущего вызова. Умножение на разность времени между кадрами на перемещение позволяет добиться одинаковой
      скорости анимации не зависимо от возможностей устройств и тормозов.
    </p>
    <img style="width: 80%" src="code3.png">
    <div style="height: 300px"></div>

    <h2> А это уже вебГЛ, вершинный и пиксельный шейдер написаны на GLSL</h2>
    <p>Здесь реализована как раз цепочка перемножения матриц в вершинном шейдере. А расчет освещения и вывод
      элементов выполняется пиксельным
    </p>
    <img style="width: 80%" src="code4.png">
    
    <div style="height: 300px"></div>
    <h2>Задаем матрицы аналогично и запускаем webGL рендеринг</h2>
    <p>Фунция очень похожа на функцию вывода без webGL. Тем не менее посмотрим следующую демку, и она 
      не тормозит. Производительность выше в сотни раз. Так же решена проблема с z-буфером.
    </p>
    <img style="width: 80%" src="code5.png">

    <div style="height: 300px"></div>
    <img style="width: 80%" src="im1.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im2.png">
    <div style="height: 300px"></div>
    
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im4.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im5.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im6.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im7.png">

    <div style="height: 300px"></div>
    <img style="width: 80%" src="im8.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im9.png">
    <div style="height: 300px"></div>
    
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im10.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im11.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im12.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="im13.png">

    <div style="height: 300px"></div>
    <img style="width: 80%" src="im14.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="zbuf.png">
    <div style="height: 300px"></div>
    <img style="width: 80%" src="nozb.png">
    <h2>О полном цикле webGL</h2>
    <ul style="font-size:24pt;">
      <li>создаем канвас</li>
      <li>получаем ГЛ контекст</li>
      <li>записываем вершинный шейдер строкой</li>
      <li>записываем пиксельный шейдер строкой</li>
      <li>компилируем шейдеры, обьединяем в шейдерную программу (glUtils.makeShader)</li>
      <li>получаем указали на шейдерные переменные getAttribLocation, getUniformLocation</li>
      <li>устанавливаем флаги gl.enable/ gl.disable/ gl.enableVertexAttribArray</li>
      <li>загружаем файлы моделей и текстур или генерируем их (obj, png форматы или другие)</li>
      <li>создаем массивы буферов вершин на js, можно сразу типизированный int32array</li>
      <li>создаем буферы вершин, индексов или текстуры из этих файлов gl.createBuffer, gl.bindBuffer, gl.arrayData</li>
      <li>----здесь можно уже реалтайм цикл</li>
      <li>gl.useProgramm - устанавливаем шейдер</li>
      <li>gl.bindBuffer - привязываем gl-буфер, gl.vertexAttribPointer задаем текущий буфер по указателю шейдерной перменной, их может быть несколько</li>
      <li>gl.bindTexture - тоже самое с текстурой</li>
      <li>gl.setUniform задаем матрицы и другие переменные шейдеров, по известным указателям</li>
      <li>gl.drawArrays - выполняем рисование</li>
    </ul>
    

    <script src="m4.js"></script>
    <script src="vector3d.dev.js"></script>
    <script src="calc.utils.js"></script>
    <script src="obj-loader.utils.js"></script>
    <script src="tf.model.js"></script>
    <script src="control.component.js"></script>
    <script src="index.js"></script>
  </body>
</html>