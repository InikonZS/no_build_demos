Всем привет, сегодня я расскажу о программировании трехмерной графики и устройстве компьютерных игр.
У многих вероятно 3д ассоциируется с такими технологиями как openGL и Directx, возможно еще и webGL.
Однако эти технологии хоть и применяются, но не сильно упрощают работу с 3д графикой. Они просто
позволяют использовать средства видеокарты для ускорения процесса рендеринга.
В целом же необходимо понимать математику всего процесса рендеринга, а понимание всей этой математики
позволит работать с 3д как с использованием webGL так и без него.

1. основы математики

Большинство современных игр как 2д так и 3д используют векторную графику.
В основе векторной графике лежат следующие понятия:
Вершина Vertex
Полигон Poly
Сетка (модель) Mesh
Матрица Matrix

Вершины задаются вектором соответствующей размерности пространства, а так же могут содержать дополнительные
данные, например нормаль, цвет, текстурные координаты UV и другие.

Полигон в частности треугольник является примитивным обьектом для отрисовки и физических расчетов. Работа с
треугольниками значительно упрощает геометрические расчеты. Полигоны строятся из массива вершин, или массива вершин
и массива индексов. Индексирование буфера позволяет многократно использовать заданные вершины и тем самым снижает 
размер буфера. Так например для задания куба необходимо задать 36 вершин без индексов или только 8 с индексами.

Модель строится аналогично полигону.

Матрица задает трансформации обьектов. Сама матрица позволяет задавать любое линейное преобразование координаты
такое как вращение, смещение, масштабирование. Перемножение матриц позволяет комбинировать трансформации,
стоит обратить внимание, что последовательность умножений матриц влияет на результат. Произведение квадратных матриц
одинакового размера возвращает матрицу такого же размера.

Умножение вектора на матрицу применяет к вектору заданную трансформацию и возвращает новый вектор.
Для трансформации всей модели необходимо умножить на матрицу все вершины.

Для отображения векторного изображения на экране его нужно растеризовать, процесс этот называют рендерингом.

Рендеринг как правило состоит из двух этапов - трансформация вершин в координаты изображения или так называемые
экранные координаты, второй этап заполнение цветом полигонов в экранных координатах.

Преобразование координат в экранные в играх состоит из последовательности умножений исходных вершин моделей 
на матрицы, обычно выделяют
матрицу проекции
матрицу камеры
матрицу мира

Все это касается исключильно процесса отображения, но помимо этого в играх обычно требуется находить пересечения
обьектов. Нахождение пересечения двух фигур требует решение системы уравнений. Как правило это уравнения
плоскостей, параметрические уравнния прямых.

Сравним сложность вычислений в 2д и 3д.

2д: Размер вектора в однородных координатах 3, размер матрицы 3 на 3. Решения пересечений требуют только уравнений
прямых вида ax+by+c=0; Движение доступно по 2м осям, вращение по 1 оси.

3д. Размер вектора 4, матрица 4 на 4. Пересечения возможны как для плоскостей вида ax+by+cz+d=0 так и для
прямых, которые задаются системой 3х уравнений. Движение доступно по 3 осям, вращения так же уже 3.

2. канвас и вебгл

Канвас является хтмл элементов и предоставляет контекст для рисования. .getContext('2d') и getContext('webGL')
На первый взгляд их функционал значительно отличается. Действительно вебгл устроен совершенно иначе, он не дает
возможности одной функцией изобразить какой-либо примитив, для изображения простого треугольника может потребоваться
значительный обьем кода.

Попробуем применить ранее предложенный алгоритм рендеринга с использованием стандартного 2д контекста канваса.
Для изображения полигона воспользуемся методами moveTo lineTo stroke и fill. 
Модель загружается в obj формате, формируются массивы вершин и нормалей для расчета освещения.
Применяется матричные трансформы, отдельное внимание стоит уделить матрице проекции, для ее корректной работы
вектор потребуется в формате [x, y, z, w], w - мнимая координата, позволяющая определить положение точки за камерой
или перед ней. Перспектива формируется делением результирующих x y на z координату.

Анимацию реализуем через функцию requestAnimationFrame, она вызывается с частотой обновления монитора, как правило
60 герц. Так же функция вызывается с параметром timeStamp в котором находится текущее время вызова в миллисекундах.
Это позволяет реализовать анимации не зависимые от частоты кадров. На демо видим 3д модель вращающуюся по двум осям.
Таким образом каждый кадр выполняется цикл умножения каждой вершины на матрицу, которая обновляется для нового угла.

Как видно, трехмерная графика не обязательно требует webGL, это всеголишь результат несложной математики.

Посмотрим как это все будет выглядеть на webGL. Главная фишка вебгл в том, что он позволяет запускать шейдеры.
Это такие программы на языке GLSL, которые выполняются на видеокарте. Видеокарта может содержать тысячи ядер
и выполнять параллельно преобразования для тысяч вершин. Так же видеокарта отлично справляется с матричными
и векторными вычислениями. Шейдеры бывают вершинными и пиксельными. Первые преобразуют вершины и соответственно
выполняются для каждой из них, вторые выполняются для каждого пикселя на экране и задают им цвет.
Для подачи входных данных в шейдеры используются переменные объявленные с директивой attribute uniform или varying.
attribute cодержат массивы данных для каждого элемента которого выполняется шейдер, uniform - просто входная переменная,
varying - используются для передачи данных между вершинным и пиксельным шейдером.

Получается мы создаем оба шейдера, на вход даем буфер вершин, буфер нормалей как аттрибуты, матрицу проекции,
матрицу камеры и мировую матрицу как uniform. Таким образом в рендер-функции избавляемся от цикла перебирающего
все вершины. Попробуем теперь отобразить не 1, а 100 одинаковых моделей на канвас и вебгл. Как видно fps на канвасе
значительно упала, а на вебгл все работает гладко.

К сожалению шейдерный расчет не позволяет удобно получить результаты в числах, результатом его работы является изображение
на canvas, это затрудняет реализацию расчетов например выделения обьектов мышью или расчет пересечений
обьектов. Поэтому часто приходится дублировать расчеты вершинного шейдера на js, и эти расчеты очень расходные.
В игре ручной расчет координат использовался для наложения html текста поверх webGL изображения, так же для
расчета столкновений обьектов, поэтому количество таких обьектов необходимо было минимизировать.


3. Построение 3д движка

В играх содержится огромное количество обьектов, которые не только рисуются на экране, но и взаимодействуют 
между собой.
Так вывод одного обьекта состоит из нескольких стадий
загрузка с сервера модели
парсинг файла модели
создание gl буфера
создание gl шейдера
привязка текущего шейдера
привязка текущего буфера
задание матриц и других uniform
рисование модели на экране
другие расчеты

Все эти пункты необходимо разделить на предварительную загрузку и на цикл рендеринга. Цикл должен выпоняться
на частоте 60 кадров в секунду.
Логично что для одной модели и ее анимации потребуется в цикле выполнять только задание матриц и вызывать
рисование моделей. Так же можно выполнить дополнительные расчеты для взаимодействия обьектов.

В случае множества обьектов в цикл потребуется внести так же привязки буферов и шейдеров, а так же текстур.
Этот процесс происходит медленнее. 
Стоит заметить, что анимации выполняются именно в шейдерах, так анимация текстур не требует замены UV
координат в буфере, анимация обьекта не требует так же изменения буфера. Все эти расчеты производятся
шейдером, необходимо только задать необходимые переменные uniform. Это позволяет значительно ускорить цикл
рендеринга.

В случае множества обьектов взаимодействие между ними потребует решения каждого обьекта с каждым, 
этот цикл оказывается вложенным в цикл рендеринга и выполнятся уже за квадратичное время, поэтому его
оптимизация еще важнее. Так для расчетов геометрии на js следует разделять те расчеты, которые могут
быть рассчитаны до квадратичного цикла и внутри него.

таким образом можно выделить 5 блоков кода с различной сложностью вычислений и различными требованиями
- предварительная загрузка - 1 - скорость интернета
- заполнение буферов, текстур, создание шейдеров - 1 - скорость памяти, передача на видеокарту
- рендеринг - o - скорость видеокарты
- предварительные расчеты геометрии и физики - o - скорость процессора
- взаимодействие каждого обьекта с каждым - o2 - скорость процессора

Возможные способы оптимизации взаимодействия обьектов
- введения простых критериев, искючающих необходимость сложного расчета взаимодействия
  это могут быть проверки по расстоянию, по описанному параллелепипеду
- разделения пространства на чанки, бинарное разделение пространства. Метод очень мощный.
- использование упрощенных моделей относительно графической модели для расчета взаимодействия
- предварительный расчет уравнений плоскостей, центров треугольников и других значений для статических обьектов

Способы оптимизации рендеринга
- использование упрощенных моделей и текстур при большом расстоянии до обьектов
- обьединение статических обьектов в один буфер, видеокарта может быстро обрабатывать буферы в несколько
тысяч вершин, таким образом пусть есть модель кубика, и надо изобразить их как можно больше на экране.
Цикл содержащий draw arrays позволит вывести порядка 30к обьектов на частоте 60фпс. Если же предварительно
сгруппировать кубики в один гл-буфер пусть по 300 кубиков, то на выходе имеем миллион кубиков с теми же 60фпс
- группировка моделей в дерево по шейдерам, текстурам, моделям. Таким образом не требуется выполнять дополнительные
операции bind texture, bind buffer, useProgram.

Таким образом в игре движок был устроен как дерево частичной обработки. Так дерево начиналось с 4х
шейдеров, каждый из которых содержал массив моделей, каждая модель содержала массив матриц для позиционирования.
Это позволило ускорить отрисовку.
Так же в игре присутствует оптимизация обьединением множества мелких обьектов изображающих космический мусор
и значительно повышающих ощущение скорости в крупный гл-буфер, это позволило располагать их в количестве сотен
тысяч штук без тормозов, так же они динамически удаляются и появляются в зависимости от положения игрока.
Следующей оптимизацией сделано исключение дальних обьектов из расчета пересечений. Бралось максимальное расстояние
до дальней вершины относительно центра и любой объект далее этого расстояние не участвовал во взаимодействии.
Проверка пересечений с пулями была реализована с учетом их движения, по сути пересечение было не пересечением
двух моделей, а пересечением отрезка перемещения за последний кадр с полигональной сеткой модели. Это позволило
точно находить пересечения не зависимо от скорости движения и частоты кадров. Оптимизацией было упрощение пули до
материальной точки, сама модель играла исключительно визуальную роль.
Так же архитектура движка предполагала возможность помещения одних обьектов одновременно в разные деревья
для обработки. Так одинаковые модели могли приобретать различные физические свойства, важно, что при этом
обьект можно было удалить одновременно из всех деревьев полностью. На каждый элемент можно было навешивать
свои обработчики, или создавать на основе них другие более сложные обьекты. В конечном итоге работа с движком
стала подобна работе с DOM. Дерево рендерилось уже самим движком, а создание и позиционирование обьектов, а так же
задание логики игровых миссий не требовало вмешиваться в эти процессы.







